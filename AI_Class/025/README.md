# CNN

CNN은 Convolutional Neural Network의 약자로 기존 DNN에서 이미지나 영상과 같은 데이터를 처리할 때 발생하는 문제점들을 보완한 방법입니다.

## CNN의 처리방법

### 1. 픽셀화

아래와 같은 손글씨 이미지가 있다고 합시다.

![025-1](https://user-images.githubusercontent.com/63298243/103630089-888ab080-4f84-11eb-8007-2cec37b262c8.png)

이와 같은 이미지에 대해서 픽셀로 나눠볼 수 있습니다.

![025-2](https://user-images.githubusercontent.com/63298243/103630017-6db83c00-4f84-11eb-9df4-29d4631ae34f.png)

위의 빨간 네모 한칸을 1픽셀이라 생각하고, 이 픽셀에는 (R(0-255), G(0-255), B(0-255)) 사이의 컬러가 들어가 있습니다.

즉 한픽셀당 3차원의 값이 들어가게 되는 것입니다.

그러나 지금은 개념만 잡는 부분이기 때문에 이해하기 쉽도록 0과 1로만 구분이 된다고 생각해봅시다.

그렇게 된다면 아래와 같이 숫자 "8"을 나타낼 수 있습니다.
(흰 픽셀은 0, 나머지 픽셀은 1)

![025-3](https://user-images.githubusercontent.com/63298243/103630021-6ee96900-4f84-11eb-98a4-cad9e91a7f6c.png)

### 2. Convolution
딥러닝에서 사용하는 Convolution은 하나의 이미지로부터 픽셀의 연관성을 살린 여러 개의 이미지를 생성하는 것입니다.

n*n 크기의 이미지를 뽑아내서 같은 크기의 랜덤값을 가지고 있는 데이터와 픽셀을 곱해서 더해줍니다.

이때 랜덤값을 가지고 있는 n*n 데이터를 필터라고 부릅니다.

필터를 한픽셀씩 옮기며 새로운 이미지를 완성하는 방식입니다.

이렇게 새 이미지를 생성하는 방법이 Convolution입니다.

수학적으로 다시 정리해보겠습니다.

---
필터 갯수 = X  
필터 크기 = Y

이미지 크기 = Z * Z

-> 이때 만들어지는 새 이미지 크기와 갯수 : 크기 = (Z-Y+1) * (Z-Y+1), 갯수 = X개
---

이번에는 아까의 숫자 8 그림에 대해 Convolution 해봅시다.

아래 같은 3 * 3 필터 3개를 준비했다고 가정합시다.

<img width="90" alt="025-4" src="https://user-images.githubusercontent.com/63298243/103630026-70b32c80-4f84-11eb-8546-45e0f0ba5912.png">

그리고 아까 픽셀화를 한 숫자 8 이미지의 크기는 28 * 28입니다.

![025-5](https://user-images.githubusercontent.com/63298243/103630028-727cf000-4f84-11eb-999b-21513dc02971.png)

필터 1번이 한칸씩 움직이면서 새로운 이미지를 만들게 됩니다.

![025-6](https://user-images.githubusercontent.com/63298243/103630032-7446b380-4f84-11eb-8da2-16d7dafe0384.png)

![025-7](https://user-images.githubusercontent.com/63298243/103630042-790b6780-4f84-11eb-956d-1644d5ffbd95.png)

![025-8](https://user-images.githubusercontent.com/63298243/103630046-7ad52b00-4f84-11eb-8fd3-382c44ecf44f.png)

![025-9](https://user-images.githubusercontent.com/63298243/103630047-7b6dc180-4f84-11eb-8e4e-1780f62f1d73.png)

이때 만들어지는 이미지는 (28-3+1) * (28-3+1), 즉 26 * 26 크기의 새로운 이미지를 만들게 됩니다.

이러한 과정을 필터갯수인 3번 반복하면, 26 * 26의 이미지 3개가 완성됩니다.

필터의 갯수가 수백개이면, 이미지 하나를 서로다른 수백개의 이미지로 표현할 수 있습니다. 즉 이미지 100개에 필터 100개를 사용한다면 10000개의 Convolution된 이미지들을 얻을 수 있는 것입니다.

이것이 CNN의 핵심이자 "C"부분인 Convolution 과정이였습니다.

> 28 * 28 크기의 이미지를 Convolution 하면 이미지 크기가 줄어들게 되는데, 줄어든만큼 손실되었다고도 볼 수 있습니다. 이미지 크기를 padding이라는 것을 이용하여 유지하는 방법도 있습니다.

* padding : 원본 이미지의 상하좌우 테두리에 0 값을 갖는 데이터를 추가하여, Convolution을 적용한 크기가 원래의 크기와 동일하게 유지하도록 하는 방법입니다. 각 끝단 부분도 필터링을 동등하게 적용시키기 위해 사용하는 목적도 있습니다. 따라서 CNN으로 처리 된 이미지에 패딩을 추가하면 이미지를보다 정확하게 분석 할 수 있습니다. 

### 3. Pooling
Pooling은 CNN의 문제점 중 하나를 보완하는 방법입니다.

Convolution 과정을 통해서 많은 수의 이미지를 생성을 할 수 있었습니다.

큰 크기의 많은 이미지를 처리하려면 상당한 연산 시간이 걸리게 됩니다.

Convolution으로 이미지 수를 늘렸다면, Pooling으로는 이미지의 크기를 줄이게 됩니다.

n * n 크기의 Pooling 필터가 주어지면, n * n 크기중 가장 특성값 하나만 추출하게 되는 것입니다.

가장 많이 쓰게되는 pooling 방법은 Max Pooling입니다.
풀링된 픽셀내의 최댓값을 뽑아 내는 방법입니다.

<img width="608" alt="025-10" src="https://user-images.githubusercontent.com/63298243/103630048-7c065800-4f84-11eb-9606-71f965bc920b.png">

아래처럼 숫자 8 이미지에서 2 * 2의 풀링 픽셀로 나누게된다면 파란 네모 한칸이 될 것입니다.

![025-11](https://user-images.githubusercontent.com/63298243/103630052-7d378500-4f84-11eb-9af9-51cf631096e5.png)

여기서 Max Pooling을 사용한다면 파란픽셀안의 4 픽셀값중 가장 큰 픽셀하나만 뽑혀서 재구성됩니다. 28 * 28크기가 14(28/2) * 14(28/2) 크기로 줄게 되는 것입니다.

#### 4. Flatten
Convolution과 Pooling을 반복하면 이미지의 갯수는 많아지면서 크기는 점점 줄어들게 됩니다. 바로 아래의 그림처럼 말입니다.

<img width="706" alt="025-12" src="https://user-images.githubusercontent.com/63298243/103630054-7d378500-4f84-11eb-992f-3f48a181fcf7.png">

이렇게 해서 만들어지는 Output 이미지는 특정 이미지에서 얻어낸 특성 데이터라고 보면 됩니다.

이러한 2차원 특성 데이터를 1차원의 데이터로 변환시키는 과정이 Flatten 과정입니다.

아래 그림의 왼쪽이 2차원 특성 데이터이고, 이를 Flatten layer를 거치면서 오른쪽과 같은 1차원의 특성 데이터로 변환됩니다.

<img width="693" alt="025-13" src="https://user-images.githubusercontent.com/63298243/103673982-8b57c680-4fc1-11eb-9033-169d22a91c83.png">

위의 이미지를 보면 Convolution과 Pooling을 반복하여 2차원 특성데이터들을 얻어내었고, 이를 Flatten층을 거쳐서 1차원 데이터로 변환하였습니다. 그 뒤에는 앞의 DNN과 같은 NN 층을 연결하여 1차원적인 OUTPUT를 얻어낼 수 있었습니다.

이미지 하나를 수백개의 이미지로 변환하고, 이 이미지들의 특성데이터들을 종합하여 1차원 데이터화 시키는 것입니다.

위의 그림과 같이 Convolution layer과 Pooling layer를 이용해 얻은 이미지들을 Dense와 같이 분류를 위한 학습 layer에 사용하기 위해서는  1차원 데이터로 바꾸어서 학습이 되어야 합니다.

### CNN 과정 정리

간단하게 모든 과정을 글로 설명해보자면, 고양이 사진 하나를 주었을때, 그 사진하나가 주어졌을 때.  
Convolution을 통해 다양한 털 색깔을 입힌 고양이 사진 수백장을 만들어 내고  
Pooling을 통해 고양이의 특징위주로 사진 크기를 줄입니다 (고양이의 귀, 코, 눈, 발바닥 등)  
마지막으로는 Flatten을 통해 2차원이라는 이미지를 1차원 데이터화 시키는 것입니다.

이러한 방법을 통해 이미지를 학습하는 것이 CNN이였습니다.